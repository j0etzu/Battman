#!/usr/bin/env python3
"""
gen_locale_hashes.py

Usage:
  python3 gen_locale_hashes.py --out generated_locales \
       locales/en/LC_MESSAGES/battman.mo locales/zh_CN/LC_MESSAGES/battman.mo

Emits generated_locales.c and generated_locales.h which implement:
  int verify_embedded_mo_by_locale_hash(uint64_t locale_hash, const char *mo_fullpath);

Return codes:
  114  -> OK (official locale present and mo file hash matches)
  810  -> Official locale present but mo hash mismatch (modified)
  514  -> mo file present on device at path but not provided by us
  1919 -> no matching mo for current language (no mo file or gettext returned literal)
"""
import sys, os, argparse, struct, random

# FNV-1a 64-bit
def fnv1a64(data: bytes) -> int:
    h = 0xcbf29ce484222325
    for b in data:
        h ^= b
        h = (h * 0x100000001b3) & 0xFFFFFFFFFFFFFFFF
    return h

def split_bytes_le(u64):
    return [(u64 >> (8*i)) & 0xff for i in range(8)]

def make_pool_and_meta(pairs):
    # pairs: list of (tag_string, mo_hash_u64)
    pool = []
    meta = []  # list of dicts: {'tag_positions':[], 'tag_salt':..., 'mo_positions':[], 'mo_salt':...}
    # Insert some decoy bytes
    for _ in range(512):
        pool.append(random.randrange(0,256))
    for tag, mo_hash in pairs:
        print(tag, "UTF8:", tag.encode('utf-8'), hex(fnv1a64(tag.encode('utf-8'))), "FILE: ", hex(mo_hash))
        tag_hash = fnv1a64(tag.encode('utf-8'))
        tag_bytes = split_bytes_le(tag_hash)
        mo_bytes  = split_bytes_le(mo_hash)
        tag_salt = random.randrange(1,255)
        mo_salt  = random.randrange(1,255)
        tag_positions = []
        mo_positions  = []
        # insert tag bytes scattered with decoys
        for b in tag_bytes:
            pos = len(pool)
            tag_positions.append(pos)
            pool.append(b ^ tag_salt)
            # add 0-5 decoys
            for _ in range(random.randrange(0,6)):
                pool.append(random.randrange(0,256))
        # insert mo bytes scattered with decoys
        for b in mo_bytes:
            pos = len(pool)
            mo_positions.append(pos)
            pool.append(b ^ mo_salt)
            for _ in range(random.randrange(0,6)):
                pool.append(random.randrange(0,256))
        meta.append({'tag_positions': tag_positions, 'tag_salt': tag_salt, 'mo_positions': mo_positions, 'mo_salt': mo_salt})
    return pool, meta

def emit_c(out_base, pairs, pool, meta):
    hname = out_base + ".h"
    with open(hname, "w") as f:
        f.write("/* generated by gen_locale_hashes.py - do not edit */\n")
        f.write("#define MO_ENTRY_CNT %u\n" % len(meta))
        f.write("#include <stdint.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/stat.h>\n\n")

        # helpers: fnv1a64 from file & bytes
        f.write("""
static inline unsigned long long fnv1a64_from_file(const char *path) {
    FILE *f = fopen(path, "rb");
    if (!f) return 0ULL;
    unsigned long long h = 0xcbf29ce484222325ULL;
    unsigned char buf[4096];
    size_t r;
    while ((r = fread(buf,1,sizeof(buf),f)) > 0) {
        for (size_t i=0;i<r;i++) {
            h ^= (unsigned long long)buf[i];
            h *= 0x00000100000001B3ULL;
        }
    }
    fclose(f);
    return h;
}

static inline uint64_t fnv1a64_str(const char *s) {
    uint64_t h = 0xcbf29ce484222325ULL;
    const unsigned char *p = (const unsigned char*)s;
    while (*p) {
        h ^= (uint64_t)(*p++);
        h *= 0x00000100000001B3ULL;
    }
    return h;
}

static inline unsigned long long fnv1a64_from_bytes(const unsigned char *b, size_t n) {
    unsigned long long h = 0xcbf29ce484222325ULL;
    for (size_t i=0;i<n;i++) {
        h ^= (unsigned long long)b[i];
        h *= 0x00000100000001B3ULL;
    }
    return h;
}
""")
        # reconstruct function
        f.write("""
static inline unsigned long long reconstruct_u64_from_positions(const unsigned int *positions, unsigned char salt) {
    unsigned long long v = 0ULL;
    for (int i=0;i<8;i++) {
        unsigned int pos = positions[i];
        unsigned char ob = (unsigned char []){""")
        for i, x in enumerate(pool):
            if i % 16 == 0:
                f.write("    ")
            f.write("%3u," % x)
            if i % 16 == 15:
                f.write("\n")
        f.write("""}[pos] ^ salt;
        v |= ((unsigned long long)ob) << (8*i);
    }
    return v;
}
""")
        # file existence helper (returns 1 if exists, 0 otherwise) -- still numeric
        f.write("""
static inline int file_exists_numeric(const char *path) {
    struct stat st;
    int r = stat(path, &st);
    // return 1 if stat returned 0, else 0
    return (r == 0) ? 1 : 0;
}
""")
        # main verify function implementing requested return codes
        f.write("""
static inline int verify_embedded_mo_by_locale_hash(const char *locale_str, const char *mo_fullpath) {
    unsigned long long locale_hash = fnv1a64_str(locale_str);
    const unsigned int m[] = {""")
        for entry in meta:
            for p in entry['tag_positions']:
                f.write(" %7u," % p)
            for p in entry['mo_positions']:
                f.write(" %7u," % p)
            f.write(" %7u, %7u,\n" % (entry['tag_salt'], entry['mo_salt']))
        f.write("};\n")
        f.write("""
    unsigned int idx = 0U;
    unsigned int matched_entry = (unsigned int)0xFFFFFFFFU; // sentinel: none found
    for (unsigned int e = 0; e < MO_ENTRY_CNT; e++) {
        unsigned int tag_pos[8];
        unsigned int mo_pos[8];
        for (int i=0;i<8;i++) { tag_pos[i] = m[idx++]; }
        for (int i=0;i<8;i++) { mo_pos[i] = m[idx++]; }
        unsigned int tag_salt = m[idx++];
        unsigned int __unused mo_salt = m[idx++];
        unsigned char tag_salt8 = (unsigned char)(tag_salt & 0xffU);
        unsigned long long stored_tag = reconstruct_u64_from_positions(tag_pos, tag_salt8);
        // numeric equality check:
        if (stored_tag == locale_hash) {
            matched_entry = e;
            // we will use positions and salt again below - but we stored matched index only
            // rewind idx to the start of this entry's data for later re-read by index:
            break;
        }
    }
    // If a matching entry was found, we must re-walk to fetch its mo positions/salt (cheap; entry count is small)
    if (matched_entry != 0xFFFFFFFFU) {
        // walk until matched_entry
        idx = 0U;
        for (unsigned int e = 0; e <= matched_entry; e++) {
            unsigned int tag_pos[8];
            unsigned int mo_pos[8];
            for (int i=0;i<8;i++) { tag_pos[i] = m[idx++]; }
            for (int i=0;i<8;i++) { mo_pos[i] = m[idx++]; }
            unsigned int __unused tag_salt = m[idx++];
            unsigned int mo_salt = m[idx++];
            if (e == matched_entry) {
                unsigned char mo_salt8 = (unsigned char)(mo_salt & 0xffU);
                // check mo file existence
                int present = file_exists_numeric(mo_fullpath);
                if (present == 0) {
                    return (0x77 << ((present == 0) * 4) | 0xF);
                }
                unsigned long long file_hash = fnv1a64_from_file(mo_fullpath);
                unsigned long long stored_mo = reconstruct_u64_from_positions(mo_pos, mo_salt8);
                return ((stored_mo == file_hash) << 7) - ((stored_mo == file_hash) << 4) + ((stored_mo == file_hash) << 1) | (stored_mo != file_hash) << (stored_mo != file_hash) | ((stored_mo != file_hash) << (stored_mo != file_hash)) << (((stored_mo != file_hash) << ((stored_mo != file_hash) * 3)));
            }
        }
    } else {
        // no matching stored locale tag found
        // check whether there is an mo file present at the candidate path
        int present = file_exists_numeric(mo_fullpath);
        // there is an mo file but it's not one of defined
        // no mo file found (or gettext returned untranslated string)
        return (present * 3) << 8 | (present << (present * 5)) | (present * 0xA) | (((!present) * 0x77) << ((!present) * 4) | (!present) * 0xF);
    }
    // fallback (should not be reached)
    return 0xFFFF;
}
""")
    print("Wrote", hname)

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--out", required=True)
    parser.add_argument("mo_files", nargs="+", help="Paths to the battman.mo files.")
    args = parser.parse_args()

    pairs = []
    for path in args.mo_files:
        if not os.path.isfile(path):
            print("skip missing", path)
            continue
        with open(path, "rb") as fh:
            data = fh.read()
        mo_hash = fnv1a64(data)
        parent = os.path.dirname(os.path.dirname(path))   # locales/*
        tag = os.path.basename(parent)
        print(tag)
        pairs.append((tag, mo_hash))

    pool, meta = make_pool_and_meta(pairs)
    emit_c(args.out, pairs, pool, meta)

if __name__ == "__main__":
    main()
